<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Is Generative Art Dead?</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .credit {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            font-family: monospace;
            letter-spacing: 0.05em;
            transition: color 0.3s ease;
            z-index: 100;
        }

        .credit:hover {
            color: rgba(255, 255, 255, 0.7);
        }

        .refresh-hint {
            position: fixed;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.2);
            font-size: 11px;
            font-family: monospace;
            letter-spacing: 0.05em;
            opacity: 0;
            animation: fadeIn 2s ease-in-out 3s forwards;
            z-index: 100;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .credit {
                font-size: 10px;
                bottom: 15px;
                right: 15px;
            }
            .refresh-hint {
                font-size: 10px;
                top: 15px;
                right: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="refresh-hint">refresh for more</div>
    <div class="credit">generative art lives</div>

    <script>
        // Global variables
        let currentSketch;
        let time = 0;
        let mouseInfluence = { x: 0, y: 0 };

        // Sketch 1: Minimalist Geometric
        const minimalistSketch = (p) => {
            let shapes = [];
            let bgColor;
            let shapeColor;
            let textColor;
            let strokeWeight;
            let selectedFont;
            let scheme;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.angleMode(p.DEGREES);
                
                // Random color scheme with guaranteed contrast
                scheme = p.random(['light', 'dark', 'contrast']);
                if (scheme === 'light') {
                    bgColor = p.color(p.random(240, 255));
                    shapeColor = p.color(0, p.random(40, 80)); // Increased opacity for visibility
                    textColor = p.color(p.random(20, 40));
                } else if (scheme === 'dark') {
                    bgColor = p.color(p.random(10, 30));
                    shapeColor = p.color(255, p.random(40, 80)); // Increased opacity for visibility
                    textColor = p.color(p.random(220, 255));
                } else {
                    bgColor = p.random() > 0.5 ? p.color(255) : p.color(0);
                    shapeColor = bgColor.levels[0] > 128 ? p.color(0, 60) : p.color(255, 60); // Increased opacity
                    textColor = bgColor.levels[0] > 128 ? p.color(0) : p.color(255);
                }
                
                strokeWeight = p.random([1, 1.5, 2, 3]);
                selectedFont = p.random(['Arial', 'Helvetica']);
                
                // Create geometric shapes with more variety and better visibility
                let shapeCount = p.random(4, 10);
                for (let i = 0; i < shapeCount; i++) {
                    shapes.push({
                        x: p.random(p.width),
                        y: p.random(p.height),
                        size: p.random(50, 250), // Increased minimum size
                        rotation: p.random(360),
                        speed: p.random(-0.5, 0.5),
                        type: p.random(['rect', 'ellipse', 'triangle', 'line', 'hexagon']),
                        strokePattern: p.random(['solid', 'dashed', 'dotted'])
                    });
                }
            };

            p.draw = () => {
                p.background(bgColor);
                
                // Draw floating shapes with better visibility
                p.push();
                p.noFill();
                p.strokeWeight(strokeWeight);
                shapes.forEach((shape, i) => {
                    p.push();
                    p.translate(shape.x, shape.y);
                    p.rotate(shape.rotation);
                    
                    // Main shape with primary color
                    p.stroke(shapeColor);
                    
                    if (shape.strokePattern === 'dashed') {
                        p.drawingContext.setLineDash([5, 5]);
                    } else if (shape.strokePattern === 'dotted') {
                        p.drawingContext.setLineDash([2, 4]);
                    }
                    
                    switch(shape.type) {
                        case 'rect':
                            p.rect(-shape.size/2, -shape.size/2, shape.size, shape.size);
                            break;
                        case 'ellipse':
                            p.ellipse(0, 0, shape.size);
                            break;
                        case 'triangle':
                            p.triangle(0, -shape.size/2, -shape.size/2, shape.size/2, shape.size/2, shape.size/2);
                            break;
                        case 'line':
                            p.line(-shape.size/2, 0, shape.size/2, 0);
                            // Add perpendicular line for cross
                            if (p.random() > 0.5) {
                                p.line(0, -shape.size/4, 0, shape.size/4);
                            }
                            break;
                        case 'hexagon':
                            p.beginShape();
                            for (let a = 0; a < p.TWO_PI; a += p.TWO_PI / 6) {
                                let x = p.cos(a) * shape.size/2;
                                let y = p.sin(a) * shape.size/2;
                                p.vertex(x, y);
                            }
                            p.endShape(p.CLOSE);
                            break;
                    }
                    
                    // Add subtle double-line effect for better visibility
                    if (scheme === 'light' && shape.type !== 'line') {
                        p.stroke(0, 10);
                        p.strokeWeight(strokeWeight + 1);
                        switch(shape.type) {
                            case 'rect':
                                p.rect(-shape.size/2, -shape.size/2, shape.size, shape.size);
                                break;
                            case 'ellipse':
                                p.ellipse(0, 0, shape.size);
                                break;
                            case 'triangle':
                                p.triangle(0, -shape.size/2, -shape.size/2, shape.size/2, shape.size/2, shape.size/2);
                                break;
                            case 'hexagon':
                                p.beginShape();
                                for (let a = 0; a < p.TWO_PI; a += p.TWO_PI / 6) {
                                    let x = p.cos(a) * shape.size/2;
                                    let y = p.sin(a) * shape.size/2;
                                    p.vertex(x, y);
                                }
                                p.endShape(p.CLOSE);
                                break;
                        }
                    }
                    
                    p.drawingContext.setLineDash([]);
                    p.pop();
                    shape.rotation += shape.speed;
                    
                    // Gentle floating motion
                    shape.x += p.sin(p.frameCount * 0.01 + i) * 0.2;
                    shape.y += p.cos(p.frameCount * 0.01 + i) * 0.1;
                });
                p.pop();
                
                // Draw "no" with subtle elegance
                p.push();
                p.translate(p.width/2, p.height/2);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width, p.height) * 0.3);
                p.textFont(selectedFont);
                p.fill(textColor);
                p.noStroke();
                p.text('no', 0, 0);
                p.pop();
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                // Update sun position and size for new dimensions
                sunY = p.height * 0.3;
                sunSize = p.min(p.width, p.height) * 0.2;
            };
        };

        // Sketch 2: Organic Flow
        const organicFlowSketch = (p) => {
            let waves = [];
            let bgHue;
            let colorPalette;
            let flowDirection;
            let textFont;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.colorMode(p.HSB, 360, 100, 100, 100);
                
                // Random color palettes
                let paletteType = p.random(['ocean', 'sunset', 'forest', 'cosmic']);
                switch(paletteType) {
                    case 'ocean':
                        bgHue = p.random(180, 220);
                        colorPalette = [180, 200, 220, 240];
                        break;
                    case 'sunset':
                        bgHue = p.random(20, 40);
                        colorPalette = [0, 20, 40, 60];
                        break;
                    case 'forest':
                        bgHue = p.random(80, 140);
                        colorPalette = [80, 100, 120, 140];
                        break;
                    case 'cosmic':
                        bgHue = p.random(260, 300);
                        colorPalette = [260, 280, 300, 320];
                        break;
                }
                
                flowDirection = p.random(['horizontal', 'vertical', 'radial']);
                textFont = p.random(['Georgia', 'Times New Roman']);
                
                // Create waves with varied parameters
                let waveCount = p.random(4, 12);
                for (let i = 0; i < waveCount; i++) {
                    waves.push({
                        offset: i * p.random(30, 90),
                        amplitude: p.random(20, 100),
                        frequency: p.random(0.0005, 0.004),
                        color: p.random(colorPalette),
                        thickness: p.random(2, 6), // Increased minimum thickness
                        opacity: p.random(40, 80), // Increased minimum opacity
                        speed: p.random(1, 3)
                    });
                }
            };

            p.draw = () => {
                // Stable background
                p.background(bgHue, 10, 90);
                
                // Draw flowing waves based on direction
                waves.forEach(wave => {
                    p.push();
                    p.noFill();
                    p.strokeWeight(wave.thickness);
                    p.stroke(wave.color, 70, 85, wave.opacity);
                    p.beginShape();
                    
                    if (flowDirection === 'horizontal') {
                        for (let x = 0; x < p.width; x += 5) {
                            let y = p.height/2 + p.sin((x + time * wave.speed + wave.offset) * wave.frequency) * wave.amplitude;
                            y += p.noise(x * 0.01, time * 0.01) * 20;
                            p.vertex(x, y);
                        }
                    } else if (flowDirection === 'vertical') {
                        for (let y = 0; y < p.height; y += 5) {
                            let x = p.width/2 + p.sin((y + time * wave.speed + wave.offset) * wave.frequency) * wave.amplitude;
                            x += p.noise(y * 0.01, time * 0.01) * 20;
                            p.vertex(x, y);
                        }
                    } else { // radial
                        for (let angle = 0; angle < 360; angle += 5) {
                            let r = 100 + p.sin((angle + time * wave.speed + wave.offset) * wave.frequency * 0.1) * wave.amplitude;
                            r += p.noise(angle * 0.01, time * 0.01) * 30;
                            let x = p.width/2 + p.cos(p.radians(angle)) * r;
                            let y = p.height/2 + p.sin(p.radians(angle)) * r;
                            p.vertex(x, y);
                        }
                        p.endShape(p.CLOSE);
                    }
                    
                    if (flowDirection !== 'radial') p.endShape();
                    p.pop();
                });
                
                // Draw "no" with subtle organic movement
                p.push();
                p.translate(p.width/2, p.height/2);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width, p.height) * 0.35);
                p.textFont(textFont);
                
                // Text with organic color from palette
                let textColor = colorPalette[Math.floor(colorPalette.length/2)];
                
                // Subtle shadow for better visibility
                p.fill(0, 0, 0, 30);
                p.noStroke();
                p.text('no', 3, 3);
                
                // Main text
                p.fill(textColor, 80, 25);
                p.noStroke();
                
                // Very subtle organic wobble
                let wobbleX = p.sin(time * 0.002) * 1;
                let wobbleY = p.cos(time * 0.003) * 1;
                
                p.text('no', wobbleX, wobbleY);
                p.pop();
                
                time += 2;
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
        };

        // Sketch 3: Glitch Digital
        const glitchDigitalSketch = (p) => {
            let glitchAmount = 0;
            let textBuffer;
            let glitchColor;
            let bgColor;
            let scanlineIntensity;
            let glitchStyle;
            let selectedFont;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.pixelDensity(1);
                
                // Random glitch aesthetics
                let colorScheme = p.random(['matrix', 'cyber', 'vaporwave', 'terminal']);
                switch(colorScheme) {
                    case 'matrix':
                        glitchColor = p.color(0, 255, 0);
                        bgColor = p.color(0, 0, 0);
                        break;
                    case 'cyber':
                        glitchColor = p.color(0, 255, 255);
                        bgColor = p.color(10, 0, 20);
                        break;
                    case 'vaporwave':
                        glitchColor = p.color(255, 0, 255);
                        bgColor = p.color(20, 0, 40);
                        break;
                    case 'terminal':
                        glitchColor = p.color(255, 160, 0); // Brighter orange
                        bgColor = p.color(20, 10, 0);
                        break;
                }
                
                scanlineIntensity = p.random(20, 80);
                glitchStyle = p.random(['horizontal', 'vertical', 'blocks', 'displacement']);
                selectedFont = p.random(['Courier New', 'Consolas', 'Monaco']);
                
                // Create text buffer
                textBuffer = p.createGraphics(p.width, p.height);
                textBuffer.pixelDensity(1);
            };

            p.draw = () => {
                p.background(bgColor);
                
                // Less frequent, gentler glitch triggers
                if (p.frameCount % 120 === 0) {
                    glitchAmount = p.random(1) > 0.7 ? p.random(5, 20) : 0;
                }
                
                // Draw text to buffer - stable and consistent
                textBuffer.clear();
                textBuffer.push();
                textBuffer.translate(textBuffer.width/2, textBuffer.height/2);
                textBuffer.textAlign(p.CENTER, p.CENTER);
                textBuffer.textSize(p.min(p.width, p.height) * 0.4);
                textBuffer.textFont(selectedFont);
                textBuffer.fill(glitchColor);
                textBuffer.noStroke();
                
                // Add subtle digital ghost effect
                if (p.random() > 0.8) {
                    textBuffer.push();
                    textBuffer.fill(glitchColor.levels[0], glitchColor.levels[1], glitchColor.levels[2], 80);
                    textBuffer.text('no', 3, 3);
                    textBuffer.pop();
                }
                
                textBuffer.text('no', 0, 0);
                textBuffer.pop();
                
                // Apply different glitch effects
                p.image(textBuffer, 0, 0);
                
                if (glitchAmount > 0) {
                    p.loadPixels();
                    
                    switch(glitchStyle) {
                        case 'horizontal':
                            for (let i = 0; i < 3; i++) {
                                let y = p.floor(p.random(p.height));
                                let h = p.floor(p.random(1, glitchAmount));
                                let xOffset = p.floor(p.random(-glitchAmount, glitchAmount));
                                
                                for (let x = 0; x < p.width; x++) {
                                    for (let dy = 0; dy < h; dy++) {
                                        let srcY = y + dy;
                                        let dstX = (x + xOffset + p.width) % p.width;
                                        
                                        if (srcY < p.height) {
                                            let srcIndex = (srcY * p.width + x) * 4;
                                            let dstIndex = (srcY * p.width + dstX) * 4;
                                            
                                            p.pixels[dstIndex] = p.pixels[srcIndex];
                                            p.pixels[dstIndex + 1] = p.pixels[srcIndex + 1];
                                            p.pixels[dstIndex + 2] = p.pixels[srcIndex + 2];
                                        }
                                    }
                                }
                            }
                            break;
                            
                        case 'blocks':
                            for (let i = 0; i < 5; i++) {
                                let blockSize = p.random(10, 30);
                                let x = p.floor(p.random(p.width - blockSize));
                                let y = p.floor(p.random(p.height - blockSize));
                                let destX = p.floor(p.random(p.width - blockSize));
                                let destY = p.floor(p.random(p.height - blockSize));
                                
                                for (let dx = 0; dx < blockSize; dx++) {
                                    for (let dy = 0; dy < blockSize; dy++) {
                                        let srcIndex = ((y + dy) * p.width + (x + dx)) * 4;
                                        let dstIndex = ((destY + dy) * p.width + (destX + dx)) * 4;
                                        
                                        if (p.random() > 0.5) {
                                            p.pixels[dstIndex] = p.pixels[srcIndex];
                                            p.pixels[dstIndex + 1] = p.pixels[srcIndex + 1];
                                            p.pixels[dstIndex + 2] = p.pixels[srcIndex + 2];
                                        }
                                    }
                                }
                            }
                            break;
                    }
                    
                    p.updatePixels();
                }
                
                // Subtle static scanlines
                p.stroke(0, 20);
                for (let y = 0; y < p.height; y += 4) {
                    p.line(0, y, p.width, y);
                }
                
                // Rare, subtle interference
                if (p.random() > 0.98) {
                    p.fill(glitchColor.levels[0], glitchColor.levels[1], glitchColor.levels[2], 30);
                    p.rect(0, p.random(p.height), p.width, 3);
                }
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                textBuffer = p.createGraphics(p.width, p.height);
            };
        };

        // Sketch 4: Particle System
        const particleSystemSketch = (p) => {
            let particles = [];
            let attractors = [];
            let particleColor;
            let bgColor;
            let particleCount;
            let attractionStrength;
            let particleStyle;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                
                // Random particle aesthetics
                let theme = p.random(['stars', 'fireflies', 'atoms', 'dust']);
                switch(theme) {
                    case 'stars':
                        bgColor = p.color(10, 10, 30);
                        particleColor = () => p.color(255, 255, p.random(200, 255));
                        particleCount = p.random(600, 1200);
                        attractionStrength = 0.3;
                        particleStyle = 'glow';
                        break;
                    case 'fireflies':
                        bgColor = p.color(20, 30, 20);
                        particleColor = () => p.color(p.random(200, 255), 255, p.random(0, 100));
                        particleCount = p.random(300, 600);
                        attractionStrength = 0.5;
                        particleStyle = 'pulse';
                        break;
                    case 'atoms':
                        bgColor = p.color(240, 240, 245);
                        particleColor = () => p.color(p.random(20, 100), p.random(50, 150), p.random(180, 220));
                        particleCount = p.random(400, 800);
                        attractionStrength = 0.8;
                        particleStyle = 'orbit';
                        break;
                    case 'dust':
                        bgColor = p.color(40, 35, 30);
                        particleColor = () => p.color(p.random(180, 220), p.random(160, 200), p.random(140, 180));
                        particleCount = p.random(800, 1500);
                        attractionStrength = 0.2;
                        particleStyle = 'float';
                        break;
                }
                
                // Create particles with varied properties
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: p.random(p.width),
                        y: p.random(p.height),
                        vx: p.random(-1, 1),
                        vy: p.random(-1, 1),
                        size: p.random(0.5, 4),
                        color: particleColor(),
                        pulsePhase: p.random(p.TWO_PI),
                        orbitRadius: p.random(50, 150),
                        orbitSpeed: p.random(0.01, 0.03)
                    });
                }
                
                // Create attractor points with variation
                createAttractors();
            };

            function createAttractors() {
                attractors = [];
                let centerX = p.width / 2;
                let centerY = p.height / 2;
                let scale = p.min(p.width, p.height) * p.random(0.25, 0.35);
                let density = p.random(15, 30);
                
                // "n" shape with curves
                for (let i = 0; i <= density; i++) {
                    let t = i / density;
                    // Left vertical
                    attractors.push({ 
                        x: centerX - scale/2 + p.noise(t * 3) * 20, 
                        y: centerY - scale/2 + (scale * t) 
                    });
                    // Diagonal
                    attractors.push({ 
                        x: centerX - scale/2 + (scale/3 * t) + p.noise(t * 3 + 100) * 15, 
                        y: centerY - scale/2 + (scale * t) 
                    });
                    // Right vertical
                    attractors.push({ 
                        x: centerX - scale/6 + p.noise(t * 3 + 200) * 20, 
                        y: centerY - scale/2 + (scale * t) 
                    });
                }
                
                // "o" shape with imperfections
                let circlePoints = p.random(20, 40);
                for (let i = 0; i < circlePoints; i++) {
                    let angle = (i / circlePoints) * p.TWO_PI;
                    let radiusVariation = p.noise(i * 0.3) * 20;
                    let x = centerX + scale/3 + p.cos(angle) * (scale/4 + radiusVariation);
                    let y = centerY + p.sin(angle) * (scale/4 + radiusVariation);
                    attractors.push({ x, y });
                }
            }

            p.draw = () => {
                // Stable dark background
                p.background(bgColor);
                
                // Update and draw particles
                particles.forEach((particle, index) => {
                    // Find nearest attractor
                    let minDist = Infinity;
                    let nearest = null;
                    
                    attractors.forEach(attractor => {
                        let d = p.dist(particle.x, particle.y, attractor.x, attractor.y);
                        if (d < minDist) {
                            minDist = d;
                            nearest = attractor;
                        }
                    });
                    
                    // Apply attraction based on style
                    if (nearest && minDist > 5) {
                        let force = p.min(attractionStrength, 50 / minDist);
                        let angle = p.atan2(nearest.y - particle.y, nearest.x - particle.x);
                        
                        if (particleStyle === 'orbit' && minDist < 100) {
                            // Orbital motion
                            particle.vx += p.cos(angle + p.HALF_PI) * force * 0.5;
                            particle.vy += p.sin(angle + p.HALF_PI) * force * 0.5;
                        } else {
                            // Direct attraction
                            particle.vx += p.cos(angle) * force;
                            particle.vy += p.sin(angle) * force;
                        }
                    }
                    
                    // Add random drift for organic feel
                    if (particleStyle === 'float') {
                        particle.vx += p.random(-0.1, 0.1);
                        particle.vy += p.random(-0.1, 0.1);
                    }
                    
                    // Apply friction
                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Draw particle based on style
                    p.noStroke();
                    let alpha = p.map(minDist, 0, 200, 255, 50);
                    
                    switch(particleStyle) {
                        case 'glow':
                            // Glowing effect
                            for (let i = 3; i > 0; i--) {
                                p.fill(particle.color.levels[0], particle.color.levels[1], particle.color.levels[2], alpha / (i * 2));
                                p.ellipse(particle.x, particle.y, particle.size * i);
                            }
                            break;
                            
                        case 'pulse':
                            // Pulsing size
                            let pulseSize = particle.size * (1 + p.sin(p.frameCount * 0.05 + particle.pulsePhase) * 0.5);
                            p.fill(particle.color.levels[0], particle.color.levels[1], particle.color.levels[2], alpha);
                            p.ellipse(particle.x, particle.y, pulseSize);
                            break;
                            
                        default:
                            // Simple particle
                            p.fill(particle.color.levels[0], particle.color.levels[1], particle.color.levels[2], alpha);
                            p.ellipse(particle.x, particle.y, particle.size);
                    }
                });
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                createAttractors();
            };
            
            p.mousePressed = () => {
                // Explode particles from mouse
                particles.forEach(particle => {
                    let d = p.dist(p.mouseX, p.mouseY, particle.x, particle.y);
                    if (d < 200) {
                        let angle = p.atan2(particle.y - p.mouseY, particle.x - p.mouseX);
                        let force = p.map(d, 0, 200, 10, 0);
                        particle.vx += p.cos(angle) * force;
                        particle.vy += p.sin(angle) * force;
                    }
                });
            };
        };

        // Sketch 5: Kinetic Typography
        const kineticTypographySketch = (p) => {
            let letters = [];
            let physics;
            let colorScheme;
            let animationStyle;
            let selectedFont;
            let fontSize;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                
                // Random physics parameters
                physics = {
                    gravity: p.random(-0.1, 0.1),
                    friction: p.random(0.85, 0.98),
                    elasticity: p.random(0.5, 0.9),
                    magnetism: p.random(0.01, 0.1)
                };
                
                // Random color schemes
                let schemes = [
                    { bg: [255, 250, 240], text: [20, 20, 30], accent: [255, 100, 100] },
                    { bg: [20, 20, 30], text: [255, 255, 255], accent: [100, 200, 255] },
                    { bg: [250, 240, 230], text: [50, 40, 30], accent: [255, 150, 0] },
                    { bg: [40, 40, 50], text: [200, 255, 200], accent: [255, 200, 255] }
                ];
                colorScheme = p.random(schemes);
                
                animationStyle = p.random(['magnetic', 'explosive', 'elastic', 'swarm', 'gravity']);
                selectedFont = p.random(['Helvetica', 'Arial', 'Georgia']);
                fontSize = p.min(p.width, p.height) * 0.4;
                
                setupLetters();
            };

            function setupLetters() {
                letters = [];
                
                let spacing = fontSize * 0.6;
                
                // "n" letter
                letters.push({
                    char: 'n',
                    x: p.random(p.width),
                    y: p.random(p.height),
                    targetX: p.width/2 - spacing/2,
                    targetY: p.height/2,
                    vx: p.random(-5, 5),
                    vy: p.random(-5, 5),
                    rotation: 0,
                    targetRotation: 0,
                    rotationSpeed: 0,
                    scale: 1,
                    targetScale: 1
                });
                
                // "o" letter
                letters.push({
                    char: 'o',
                    x: p.random(p.width),
                    y: p.random(p.height),
                    targetX: p.width/2 + spacing/2,
                    targetY: p.height/2,
                    vx: p.random(-5, 5),
                    vy: p.random(-5, 5),
                    rotation: 0,
                    targetRotation: 0,
                    rotationSpeed: 0,
                    scale: 1,
                    targetScale: 1
                });
            }

            p.draw = () => {
                // Dynamic background
                p.background(colorScheme.bg[0], colorScheme.bg[1], colorScheme.bg[2]);
                
                // Draw connecting lines sometimes
                if (animationStyle === 'magnetic' && letters.length > 1) {
                    p.strokeWeight(2);
                    p.stroke(colorScheme.accent[0], colorScheme.accent[1], colorScheme.accent[2], 50);
                    p.line(letters[0].x, letters[0].y, letters[1].x, letters[1].y);
                }
                
                letters.forEach((letter, i) => {
                    // Apply different animation styles
                    switch(animationStyle) {
                        case 'magnetic':
                            // Magnetic attraction
                            let force = physics.magnetism;
                            letter.vx += (letter.targetX - letter.x) * force;
                            letter.vy += (letter.targetY - letter.y) * force;
                            break;
                            
                        case 'explosive':
                            // Explosive settling
                            if (p.frameCount < 60) {
                                letter.vx += p.random(-1, 1);
                                letter.vy += p.random(-1, 1);
                            } else {
                                letter.vx += (letter.targetX - letter.x) * 0.02;
                                letter.vy += (letter.targetY - letter.y) * 0.02;
                            }
                            break;
                            
                        case 'elastic':
                            // Elastic behavior
                            let dx = letter.targetX - letter.x;
                            let dy = letter.targetY - letter.y;
                            letter.vx += dx * physics.elasticity * 0.02;
                            letter.vy += dy * physics.elasticity * 0.02;
                            break;
                            
                        case 'swarm':
                            // Swarm behavior
                            letter.vx += p.sin(time * 0.02 + i) * 0.5;
                            letter.vy += p.cos(time * 0.02 + i) * 0.5;
                            letter.vx += (letter.targetX - letter.x) * 0.01;
                            letter.vy += (letter.targetY - letter.y) * 0.01;
                            break;
                            
                        case 'gravity':
                            // Gravity wells
                            letter.vy += physics.gravity;
                            if (letter.y > letter.targetY) {
                                letter.vy *= -physics.elasticity;
                                letter.y = letter.targetY;
                            }
                            letter.vx += (letter.targetX - letter.x) * 0.02;
                            break;
                    }
                    
                    // Apply physics
                    letter.vx *= physics.friction;
                    letter.vy *= physics.friction;
                    letter.x += letter.vx;
                    letter.y += letter.vy;
                    
                    // Keep rotation minimal and smooth
                    letter.rotation = p.lerp(letter.rotation, letter.targetRotation, 0.1);
                    
                    // Add very subtle wobble when close to target
                    let distToTarget = p.dist(letter.x, letter.y, letter.targetX, letter.targetY);
                    if (distToTarget < 20) {
                        letter.x += p.sin(time * 0.02 + i) * 0.5;
                        letter.y += p.cos(time * 0.02 + i) * 0.5;
                    }
                    
                    // Draw subtle shadow
                    p.push();
                    p.translate(letter.x + 3, letter.y + 3);
                    p.rotate(p.radians(letter.rotation));
                    p.scale(letter.scale);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(fontSize);
                    p.textFont(selectedFont);
                    p.fill(0, 0, 0, 40);
                    p.noStroke();
                    p.text(letter.char, 0, 0);
                    p.pop();
                    
                    // Draw letter
                    p.push();
                    p.translate(letter.x, letter.y);
                    p.rotate(p.radians(letter.rotation));
                    p.scale(letter.scale);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(fontSize);
                    p.textFont(selectedFont);
                    p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2]);
                    p.noStroke();
                    p.text(letter.char, 0, 0);
                    p.pop();
                });
                
                time++;
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                fontSize = p.min(p.width, p.height) * 0.4;
                setupLetters();
            };

            p.mousePressed = () => {
                // Gentle interaction
                letters.forEach(letter => {
                    let d = p.dist(p.mouseX, p.mouseY, letter.x, letter.y);
                    if (d < 100) {
                        letter.vx += (letter.x - p.mouseX) * 0.1;
                        letter.vy += (letter.y - p.mouseY) * 0.1;
                    }
                });
            };
        };

        // Sketch 6: Color Field Abstract
        const colorFieldSketch = (p) => {
            let colorShift = 0;
            let fields = [];
            let palette;
            let composition;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.colorMode(p.HSB, 360, 100, 100, 100);
                
                // Random color palettes
                let paletteType = p.random(['rothko', 'newman', 'mondrian', 'richter']);
                switch(paletteType) {
                    case 'rothko':
                        palette = {
                            base: p.random(0, 360),
                            range: 60,
                            saturation: [40, 80],
                            brightness: [30, 90]
                        };
                        composition = 'layered';
                        break;
                    case 'newman':
                        palette = {
                            base: p.random([0, 200, 240]), // Red, blue, or purple
                            range: 20,
                            saturation: [80, 100],
                            brightness: [20, 80]
                        };
                        composition = 'vertical';
                        break;
                    case 'mondrian':
                        palette = {
                            base: 0,
                            range: 360,
                            saturation: [0, 100],
                            brightness: [20, 100]
                        };
                        composition = 'grid';
                        break;
                    case 'richter':
                        palette = {
                            base: p.random(0, 360),
                            range: 180,
                            saturation: [30, 90],
                            brightness: [40, 95]
                        };
                        composition = 'blur';
                        break;
                }
                
                // Create random color fields with better contrast
                let fieldCount = p.random(2, 6);
                for (let i = 0; i < fieldCount; i++) {
                    let opacity = composition === 'layered' ? p.random(30, 70) : p.random(40, 80);
                    fields.push({
                        x: p.random(p.width),
                        y: p.random(p.height),
                        width: p.random(200, 600),
                        height: p.random(200, 600),
                        hue: (palette.base + p.random(-palette.range/2, palette.range/2) + 360) % 360,
                        saturation: p.random(palette.saturation[0], palette.saturation[1]),
                        brightness: p.random(palette.brightness[0], palette.brightness[1]),
                        opacity: opacity,
                        rotation: p.random(-45, 45),
                        shape: p.random(['rect', 'ellipse', 'gradient'])
                    });
                }
            };

            p.draw = () => {
                // Dynamic gradient background
                for (let y = 0; y <= p.height; y += 2) {
                    let inter = p.map(y, 0, p.height, 0, 1);
                    let hue = (palette.base + colorShift + inter * 30) % 360;
                    p.stroke(hue, 25, 85);
                    p.strokeWeight(2);
                    p.line(0, y, p.width, y);
                }
                
                // Draw color fields based on composition
                p.push();
                
                if (composition === 'layered') {
                    // Rothko-style layered rectangles
                    p.blendMode(p.MULTIPLY);
                    fields.forEach(field => {
                        p.push();
                        p.noStroke();
                        p.fill(field.hue, field.saturation, field.brightness, field.opacity);
                        
                        if (field.shape === 'gradient') {
                            // Create gradient effect
                            for (let i = 0; i < field.height; i += 5) {
                                let alpha = p.map(i, 0, field.height, field.opacity, 0);
                                p.fill(field.hue, field.saturation, field.brightness, alpha);
                                p.rect(field.x - field.width/2, field.y - field.height/2 + i, field.width, 5);
                            }
                        } else {
                            p.translate(field.x, field.y);
                            p.rotate(p.radians(field.rotation));
                            if (field.shape === 'rect') {
                                p.rect(-field.width/2, -field.height/2, field.width, field.height);
                            } else {
                                p.ellipse(0, 0, field.width, field.height);
                            }
                        }
                        p.pop();
                    });
                } else if (composition === 'vertical') {
                    // Newman-style vertical bands
                    p.noStroke();
                    let stripeWidth = p.width / fields.length;
                    fields.forEach((field, i) => {
                        p.fill(field.hue, field.saturation, field.brightness, 80);
                        p.rect(i * stripeWidth, 0, stripeWidth, p.height);
                    });
                } else if (composition === 'grid') {
                    // Mondrian-style grid
                    p.strokeWeight(8);
                    p.stroke(0);
                    fields.forEach(field => {
                        p.fill(field.saturation < 50 ? 255 : field.hue, 
                               field.saturation, 
                               field.brightness);
                        p.rect(field.x - field.width/2, field.y - field.height/2, field.width, field.height);
                    });
                } else { // blur
                    // Richter-style blurred stripes
                    let stripeHeight = p.height / fields.length;
                    fields.forEach((field, i) => {
                        p.noStroke();
                        p.fill(field.hue, field.saturation, field.brightness);
                        p.rect(0, i * stripeHeight, p.width, stripeHeight);
                    });
                    p.filter(p.BLUR, 3);
                }
                
                p.pop();
                
                // Draw "no" text with clean treatment
                p.push();
                p.blendMode(p.NORMAL);
                p.translate(p.width/2, p.height/2);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width, p.height) * 0.3);
                
                // Font selection based on composition
                let fontChoice = composition === 'grid' ? 'Arial' : 'Georgia';
                p.textFont(fontChoice);
                
                // Text color based on background
                let avgBrightness = fields.reduce((sum, field) => sum + field.brightness, 0) / fields.length;
                if (avgBrightness > 60) {
                    p.fill(0, 0, 10);
                } else {
                    p.fill(0, 0, 95);
                }
                
                p.noStroke();
                
                // Add subtle shadow for depth
                if (composition !== 'grid') {
                    p.push();
                    p.fill(0, 0, 0, 25);
                    p.text('no', 4, 4);
                    p.pop();
                }
                
                // Very subtle outline for light backgrounds
                if (avgBrightness > 85) {
                    p.push();
                    p.noFill();
                    p.stroke(0, 0, 0, 40);
                    p.strokeWeight(1.5);
                    p.text('no', 0, 0);
                    p.pop();
                }
                
                p.text('no', 0, 0);
                p.pop();
                
                colorShift += 0.1;
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
            
            p.mousePressed = () => {
                // Regenerate color fields
                fields.forEach(field => {
                    field.hue = (field.hue + p.random(-30, 30) + 360) % 360;
                    field.opacity = p.random(20, 60);
                });
            };
        };

        // Sketch 7: Mathematical Patterns - "Harmonic Resonance"
        const mathematicalPatternSketch = (p) => {
            let phase = 0;
            let palette;
            let composition;
            let noiseField = [];
            let goldenRatio = 1.618033988749;
            let traits;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                p.angleMode(p.RADIANS);
                
                // Generate artistic traits (like Art Blocks pieces)
                traits = {
                    // Core mathematical parameters
                    frequency: p.random(2, 8),
                    amplitude: p.random(0.3, 0.7),
                    complexity: p.floor(p.random(3, 9)),
                    symmetry: p.random(['radial', 'bilateral', 'translational', 'none']),
                    
                    // Compositional parameters
                    density: p.random(0.4, 0.9),
                    scale: p.random(0.5, 1.5),
                    rotation: p.random(p.TWO_PI),
                    
                    // Artistic parameters
                    strokeStyle: p.random(['delicate', 'bold', 'varied']),
                    flowField: p.random() > 0.5,
                    layers: p.floor(p.random(3, 7))
                };
                
                // Sophisticated color palettes inspired by art history
                let paletteType = p.random(['monet', 'rothko', 'richter', 'klee', 'kandinsky']);
                generatePalette(paletteType);
                
                // Initialize noise field for organic variations
                p.noiseSeed(p.random(10000));
                for (let i = 0; i < 10; i++) {
                    noiseField.push(p.random(1000));
                }
            };
            
            function generatePalette(type) {
                switch(type) {
                    case 'monet':
                        // Impressionist water lilies palette
                        palette = {
                            bg: p.color(245, 242, 237),
                            colors: [
                                p.color(67, 97, 113, 180),
                                p.color(146, 168, 172, 180),
                                p.color(216, 219, 196, 180),
                                p.color(157, 129, 137, 180),
                                p.color(95, 119, 124, 180)
                            ],
                            accent: p.color(204, 126, 163, 200)
                        };
                        break;
                        
                    case 'rothko':
                        // Color field emotional palette
                        palette = {
                            bg: p.color(35, 31, 32),
                            colors: [
                                p.color(140, 46, 49, 150),
                                p.color(198, 83, 62, 150),
                                p.color(64, 41, 54, 150),
                                p.color(89, 60, 72, 150)
                            ],
                            accent: p.color(217, 160, 102, 180)
                        };
                        break;
                        
                    case 'richter':
                        // Contemporary abstract palette
                        palette = {
                            bg: p.color(250, 250, 245),
                            colors: [
                                p.color(45, 45, 45, 120),
                                p.color(230, 0, 18, 120),
                                p.color(251, 176, 59, 120),
                                p.color(36, 107, 206, 120),
                                p.color(80, 80, 80, 120)
                            ],
                            accent: p.color(255, 255, 255, 200)
                        };
                        break;
                        
                    case 'klee':
                        // Bauhaus geometric palette
                        palette = {
                            bg: p.color(242, 234, 214),
                            colors: [
                                p.color(193, 51, 47, 160),
                                p.color(237, 177, 88, 160),
                                p.color(59, 93, 124, 160),
                                p.color(122, 148, 128, 160)
                            ],
                            accent: p.color(38, 38, 38, 200)
                        };
                        break;
                        
                    case 'kandinsky':
                        // Spiritual abstract palette
                        palette = {
                            bg: p.color(236, 228, 212),
                            colors: [
                                p.color(216, 71, 39, 140),
                                p.color(38, 83, 122, 140),
                                p.color(235, 196, 74, 140),
                                p.color(47, 44, 42, 140),
                                p.color(163, 51, 39, 140)
                            ],
                            accent: p.color(255, 255, 255, 180)
                        };
                        break;
                }
            }

            p.draw = () => {
                // Sophisticated gradient background
                drawArtisticBackground();
                
                // Main composition using golden ratio positioning
                p.push();
                let centerX = p.width / goldenRatio;
                let centerY = p.height / goldenRatio;
                p.translate(centerX, centerY);
                p.rotate(traits.rotation);
                
                // Layer multiple mathematical forms
                for (let layer = 0; layer < traits.layers; layer++) {
                    p.push();
                    let layerScale = p.map(layer, 0, traits.layers, 1, 0.3);
                    p.scale(layerScale * traits.scale);
                    
                    drawHarmonicForm(layer);
                    p.pop();
                }
                
                p.pop();
                
                // Add compositional elements
                if (traits.flowField) {
                    drawFlowField();
                }
                
                // Draw "no" with artistic integration
                drawArtisticText();
                
                phase += 0.003;
            };
            
            function drawArtisticBackground() {
                // Create subtle gradient with noise
                let baseR = p.red(palette.bg);
                let baseG = p.green(palette.bg);
                let baseB = p.blue(palette.bg);
                
                for (let y = 0; y < p.height; y += 2) {
                    let inter = y / p.height;
                    let noiseVal = p.noise(y * 0.002, phase) * 0.1;
                    
                    // Ensure gradient doesn't wash out to pure white
                    let maxBrightness = p.brightness(palette.bg) > 80 ? 0.95 : 0.9;
                    let r = baseR * (maxBrightness - inter * 0.1 + noiseVal);
                    let g = baseG * (maxBrightness - inter * 0.1 + noiseVal);
                    let b = baseB * (maxBrightness - inter * 0.1 + noiseVal);
                    
                    p.stroke(r, g, b);
                    p.strokeWeight(2);
                    p.line(0, y, p.width, y);
                }
            }
            
            function drawHarmonicForm(layer) {
                p.noFill();
                
                // Complex harmonic oscillator
                let points = [];
                let numPoints = traits.complexity * 50;
                
                for (let i = 0; i < numPoints; i++) {
                    let t = p.map(i, 0, numPoints, 0, p.TWO_PI * traits.frequency);
                    
                    // Multi-frequency harmonic motion
                    let x = 0;
                    let y = 0;
                    
                    for (let h = 1; h <= traits.complexity; h++) {
                        let harmonic = 1 / h;
                        x += p.sin(t * h + phase * h + noiseField[h % 10]) * 100 * harmonic * traits.amplitude;
                        y += p.cos(t * h * goldenRatio + phase * h + noiseField[(h + 5) % 10]) * 100 * harmonic * traits.amplitude;
                    }
                    
                    // Add organic variation
                    let noiseScale = 0.01;
                    x += p.noise(t * noiseScale, phase, layer) * 50 - 25;
                    y += p.noise(t * noiseScale, phase + 100, layer) * 50 - 25;
                    
                    points.push({x, y, t});
                }
                
                // Apply symmetry transformations
                drawWithSymmetry(points, layer);
            }
            
            function drawWithSymmetry(points, layer) {
                let colorIndex = layer % palette.colors.length;
                let baseColor = palette.colors[colorIndex];
                
                switch(traits.symmetry) {
                    case 'radial':
                        let segments = traits.complexity;
                        for (let s = 0; s < segments; s++) {
                            p.push();
                            p.rotate(p.TWO_PI / segments * s);
                            drawCurve(points, baseColor, layer);
                            p.pop();
                        }
                        break;
                        
                    case 'bilateral':
                        drawCurve(points, baseColor, layer);
                        p.push();
                        p.scale(-1, 1);
                        drawCurve(points, baseColor, layer);
                        p.pop();
                        break;
                        
                    case 'translational':
                        for (let tx = -1; tx <= 1; tx++) {
                            for (let ty = -1; ty <= 1; ty++) {
                                p.push();
                                p.translate(tx * 200, ty * 200);
                                drawCurve(points, baseColor, layer);
                                p.pop();
                            }
                        }
                        break;
                        
                    default:
                        drawCurve(points, baseColor, layer);
                }
            }
            
            function drawCurve(points, baseColor, layer) {
                // Sophisticated stroke styling
                p.beginShape();
                
                points.forEach((point, i) => {
                    let alpha = p.map(i, 0, points.length, 100, 20);
                    
                    // Variable stroke weight
                    let weight;
                    switch(traits.strokeStyle) {
                        case 'delicate':
                            weight = p.map(i, 0, points.length, 1, 3);
                            break;
                        case 'bold':
                            weight = p.map(p.sin(point.t * 2), -1, 1, 2, 6);
                            break;
                        case 'varied':
                            weight = p.noise(point.t * 0.1, layer) * 5 + 1;
                            break;
                    }
                    
                    p.strokeWeight(weight * traits.density);
                    p.stroke(p.red(baseColor), p.green(baseColor), p.blue(baseColor), alpha * traits.density);
                    
                    p.vertex(point.x, point.y);
                });
                
                p.endShape();
            }
            
            function drawFlowField() {
                // Subtle flow field overlay
                p.push();
                let spacing = 30 / traits.density;
                
                for (let x = 0; x < p.width; x += spacing) {
                    for (let y = 0; y < p.height; y += spacing) {
                        let angle = p.noise(x * 0.003, y * 0.003, phase) * p.TWO_PI * 2;
                        let length = p.noise(x * 0.003 + 100, y * 0.003 + 100, phase) * 15;
                        
                        p.push();
                        p.translate(x, y);
                        p.rotate(angle);
                        p.stroke(p.red(palette.accent), p.green(palette.accent), p.blue(palette.accent), 60);
                        p.strokeWeight(1.5);
                        p.line(0, 0, length, 0);
                        p.pop();
                    }
                }
                p.pop();
            }
            
            function drawArtisticText() {
                p.push();
                p.translate(p.width/2, p.height/2);
                
                // Sophisticated text treatment
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width, p.height) * 0.28);
                p.textFont('Futura');
                
                // Multiple text layers for depth
                // Shadow/glow layer
                for (let i = 5; i > 0; i--) {
                    p.fill(
                        p.red(palette.accent), 
                        p.green(palette.accent), 
                        p.blue(palette.accent), 
                        15 * i
                    );
                    p.push();
                    p.scale(1 + i * 0.005);
                    p.text('no', 0, 0);
                    p.pop();
                }
                
                // Main text
                if (p.brightness(palette.bg) > 50) {
                    // Add subtle outline for very light backgrounds
                    if (p.brightness(palette.bg) > 85) {
                        p.stroke(20, 20, 30, 30);
                        p.strokeWeight(1);
                    } else {
                        p.noStroke();
                    }
                    p.fill(20, 20, 30);
                } else {
                    p.noStroke();
                    p.fill(250, 250, 245);
                }
                p.text('no', 0, 0);
                
                p.pop();
            }

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
            
            p.keyPressed = () => {
                if (p.key === 's' || p.key === 'S') {
                    p.save(`harmonic-resonance-${Date.now()}.png`);
                }
            };
        };

        // Sketch 8: Neon Synthwave
        const neonSynthwaveSketch = (p) => {
            let gridOffset = 0;
            let stars = [];
            let colorScheme;
            let gridStyle;
            let sunStyle;
            let showSun;
            let sunY;
            let sunSize;
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('canvas-container');
                
                // Random color schemes
                let schemes = [
                    { 
                        name: 'classic',
                        bg: [10, 0, 20], 
                        grid: [255, 0, 255], 
                        grid2: [0, 255, 255],
                        text: [255, 0, 255],
                        glow: [0, 255, 255]
                    },
                    { 
                        name: 'sunset',
                        bg: [20, 0, 10], 
                        grid: [255, 100, 0], 
                        grid2: [255, 0, 100],
                        text: [255, 200, 0],
                        glow: [255, 0, 100]
                    },
                    { 
                        name: 'vapor',
                        bg: [20, 0, 40], 
                        grid: [255, 100, 255], 
                        grid2: [100, 255, 255],
                        text: [255, 200, 255],
                        glow: [100, 255, 255]
                    },
                    { 
                        name: 'miami',
                        bg: [10, 10, 30], 
                        grid: [255, 20, 147], 
                        grid2: [0, 191, 255],
                        text: [255, 255, 255],
                        glow: [255, 20, 147]
                    }
                ];
                colorScheme = p.random(schemes);
                
                gridStyle = p.random(['perspective', 'flat', 'curved', 'infinite']);
                sunStyle = p.random(['solid', 'gradient', 'stripes', 'glitch']);
                
                // Decide once whether to show sun
                showSun = p.random() > 0.3;
                sunY = p.height * 0.3;
                sunSize = p.min(p.width, p.height) * 0.2;
                
                // Create stars
                for (let i = 0; i < 100; i++) {
                    stars.push({
                        x: p.random(p.width),
                        y: p.random(p.height * 0.5),
                        size: p.random(0.5, 2),
                        twinkle: p.random(0.5, 1)
                    });
                }
            };

            p.draw = () => {
                // Gradient background
                for (let y = 0; y <= p.height; y += 2) {
                    let inter = p.map(y, 0, p.height, 0, 1);
                    let r = p.lerp(colorScheme.bg[0], colorScheme.bg[0] * 2, inter);
                    let g = p.lerp(colorScheme.bg[1], colorScheme.bg[1] * 2, inter);
                    let b = p.lerp(colorScheme.bg[2], colorScheme.bg[2] * 1.5, inter);
                    p.stroke(r, g, b);
                    p.strokeWeight(2);
                    p.line(0, y, p.width, y);
                }
                
                // Draw stars with gentle twinkling
                stars.forEach(star => {
                    p.noStroke();
                    let alpha = p.sin(p.frameCount * star.twinkle * 0.02) * 50 + 180;
                    p.fill(255, 255, 255, alpha);
                    p.ellipse(star.x, star.y, star.size);
                });
                
                // Draw sun/moon with stable appearance
                if (showSun) {
                    p.push();
                    
                    // Draw sun based on style (no random selection per frame)
                    switch(sunStyle) {
                        case 'gradient':
                            // Smooth gradient sun
                            for (let i = sunSize; i > 0; i -= 8) {
                                let alpha = p.map(i, 0, sunSize, 80, 0);
                                p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2], alpha);
                                p.noStroke();
                                p.ellipse(p.width/2, sunY, i);
                            }
                            break;
                            
                        case 'stripes':
                            // Striped sun (static)
                            p.push();
                            p.translate(p.width/2, sunY);
                            p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2]);
                            p.noStroke();
                            p.ellipse(0, 0, sunSize);
                            p.stroke(colorScheme.bg[0], colorScheme.bg[1], colorScheme.bg[2]);
                            p.strokeWeight(3);
                            for (let y = -sunSize/2; y < sunSize/2; y += 8) {
                                let x = p.sqrt((sunSize/2) * (sunSize/2) - y * y);
                                p.line(-x, y, x, y);
                            }
                            p.pop();
                            break;
                            
                        case 'glitch':
                            // Subtle glitch effect
                            p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2]);
                            p.noStroke();
                            p.ellipse(p.width/2, sunY, sunSize);
                            p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2], 50);
                            p.ellipse(p.width/2 + 3, sunY, sunSize);
                            break;
                            
                        default:
                            // Solid sun
                            p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2]);
                            p.noStroke();
                            p.ellipse(p.width/2, sunY, sunSize);
                    }
                    p.pop();
                }
                
                // Draw grid based on style
                p.push();
                p.strokeWeight(1);
                
                switch(gridStyle) {
                    case 'perspective':
                        // Horizontal lines
                        for (let y = p.height/2; y < p.height; y += 20) {
                            let perspective = p.map(y, p.height/2, p.height, 0, 1);
                            let yOffset = (gridOffset * 0.5) % 20;
                            p.stroke(colorScheme.grid[0], colorScheme.grid[1], colorScheme.grid[2], 60 * (1 - perspective));
                            p.line(0, y + yOffset, p.width, y + yOffset);
                        }
                        
                        // Vertical lines with perspective
                        let centerX = p.width/2;
                        for (let x = -30; x <= 30; x++) {
                            p.stroke(colorScheme.grid2[0], colorScheme.grid2[1], colorScheme.grid2[2], 40);
                            p.line(
                                centerX + x * 40, 
                                p.height/2, 
                                centerX + x * 100, 
                                p.height
                            );
                        }
                        break;
                        
                    case 'flat':
                        // Simple grid
                        p.stroke(colorScheme.grid[0], colorScheme.grid[1], colorScheme.grid[2], 50);
                        for (let x = 0; x < p.width; x += 60) {
                            p.line(x, p.height/2, x, p.height);
                        }
                        for (let y = p.height/2; y < p.height; y += 60) {
                            p.line(0, y, p.width, y);
                        }
                        break;
                        
                    case 'curved':
                        // Curved grid lines (smoother)
                        for (let y = p.height/2; y < p.height; y += 30) {
                            p.noFill();
                            p.stroke(colorScheme.grid[0], colorScheme.grid[1], colorScheme.grid[2], 50);
                            p.beginShape();
                            for (let x = 0; x <= p.width; x += 20) {
                                let curve = p.sin(x * 0.005 + gridOffset * 0.005) * 10;
                                p.vertex(x, y + curve);
                            }
                            p.endShape();
                        }
                        break;
                        
                    case 'infinite':
                        // Infinite zoom effect (smoother)
                        p.translate(p.width/2, p.height * 0.75);
                        for (let i = 0; i < 10; i++) {
                            let size = (i * 120 + gridOffset) % 1200;
                            let alpha = p.map(size, 0, 1200, 50, 0);
                            p.stroke(colorScheme.grid[0], colorScheme.grid[1], colorScheme.grid[2], alpha);
                            p.strokeWeight(1.5);
                            p.noFill();
                            p.rect(-size/2, -size/4, size, size/2);
                        }
                        break;
                }
                p.pop();
                
                // Draw glowing "no"
                p.push();
                p.translate(p.width/2, p.height/2);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width, p.height) * 0.4);
                p.textFont('Arial Black');
                
                // Stable glow layers
                for (let i = 3; i > 0; i--) {
                    let alpha = p.map(i, 0, 3, 60, 20);
                    let blur = p.map(i, 0, 3, 0, 12);
                    p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2], alpha);
                    p.noStroke();
                    p.drawingContext.shadowBlur = blur;
                    p.drawingContext.shadowColor = `rgb(${colorScheme.glow[0]}, ${colorScheme.glow[1]}, ${colorScheme.glow[2]})`;
                    p.text('no', 0, 0);
                }
                
                // Main text
                p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2]);
                p.noStroke();
                p.drawingContext.shadowBlur = 18;
                p.drawingContext.shadowColor = `rgb(${colorScheme.glow[0]}, ${colorScheme.glow[1]}, ${colorScheme.glow[2]})`;
                p.text('no', 0, 0);
                
                // Inner highlight
                p.fill(255);
                p.drawingContext.shadowBlur = 0;
                p.textSize(p.min(p.width, p.height) * 0.38);
                p.text('no', 0, 0);
                
                // Subtle scanlines
                p.stroke(0, 10);
                let fontSize = p.min(p.width, p.height) * 0.4;
                for (let y = -fontSize/2; y < fontSize/2; y += 6) {
                    p.line(-fontSize, y, fontSize, y);
                }
                
                p.pop();
                
                // Gentle glitch effects
                if (p.random() > 0.99) {
                    p.fill(colorScheme.text[0], colorScheme.text[1], colorScheme.text[2], 20);
                    p.rect(0, p.random(p.height), p.width, 2);
                }
                
                gridOffset += 0.5;
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
            
            p.mousePressed = () => {
                // Gentle interaction - just add a few stars
                for (let i = 0; i < 5; i++) {
                    stars.push({
                        x: p.mouseX + p.random(-20, 20),
                        y: p.mouseY + p.random(-20, 20),
                        size: p.random(0.5, 1.5),
                        twinkle: p.random(0.5, 1)
                    });
                }
            };
        };

        // Array of all sketches
        const artStyles = [
            { name: 'minimalist', sketch: minimalistSketch },
            { name: 'organicFlow', sketch: organicFlowSketch },
            { name: 'glitchDigital', sketch: glitchDigitalSketch },
            { name: 'particleSystem', sketch: particleSystemSketch },
            { name: 'kineticTypography', sketch: kineticTypographySketch },
            { name: 'colorField', sketch: colorFieldSketch },
            { name: 'mathematicalPattern', sketch: mathematicalPatternSketch },
            { name: 'neonSynthwave', sketch: neonSynthwaveSketch }
        ];

        // Initialize with random sketch
        window.addEventListener('DOMContentLoaded', () => {
            const randomStyle = artStyles[Math.floor(Math.random() * artStyles.length)];
            currentSketch = new p5(randomStyle.sketch);
            
            // Track mouse for interactive effects
            document.addEventListener('mousemove', (e) => {
                mouseInfluence.x = e.clientX / window.innerWidth;
                mouseInfluence.y = e.clientY / window.innerHeight;
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentSketch) {
                currentSketch.windowResized();
            }
        });
    </script>
</body>
</html>
